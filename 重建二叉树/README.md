# 题目描述

输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都
不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。

# 思路

前序： 1,2,4,7,3,5,6,8

中序：4,7,2,1,5,3,8,6



根据前序知道root节点为1，根据root节点位置在中序序列中1前面的是左子树，1后面的是右子树。因此可以大致先确定为如下：

root: 1   左：2,4,7   右：3, 5, 6, 8.                  2,4,7  <--   1  --> 3, 5, 6, 8

​           

  

然后确定第二级两个点，根据前序序列的生成规则，左子树的第一个点2就是左子树的第二级的节点值，右子树的第一个数3就是右子树的第二级节点的值。得到第二级的节点：

root: 1  第二级左：2。 第二级右：3

同样我们在根据中序序列，中序序列是先找左子树在找root节点在找右子树，当左子树中root节点转化为2时，中序序列中2左侧的就是2的左子树，2右侧的就是2的右子树。同理得到右子树节点转换为3的时候可以得到3的左子树和右子树如下：

root： 2   左： 4，7     右：无

root：3    左： 5           右： 8，6



同理，又回到前序遍历，找到4，7中4在前面，即左子树第三级的是4，右子树中第一个出现的左子树节点是5，右子树节点是6



这样就一个8了，看中序序列，当root节点变为6， 8在root节点左侧即8是6的左子树。

构建完成：

![重建二叉树](https://github.com/duanyzhi/LeetCode_with_Python/blob/master/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91.png)

对应的后序遍历：先左后右最后root:

7,4,2,5,8,6,3,1
